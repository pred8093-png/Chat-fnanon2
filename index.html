<!doctype html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Private Space ğŸ‘©â€â¤ï¸â€ğŸ‘¨ â€” Ø¯Ø±Ø¯Ø´Ø© Ù…Ø´ÙÙ‘Ø±Ø© Ù…Ø¹ Ø³ÙŠØ±ÙØ± Ø¥Ø´Ø§Ø±Ø§Øª</title>
  <style>
    :root{
      --bg: radial-gradient(circle at 20% 20%, #0f0c29, #302b63, #24243e);
      --card: rgba(255,255,255,0.05);
      --accent: #ff6ec7;
      --accent2: #06b6d4;
      --muted: #b8b8d1;
      --text: #ffffff;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: 'Cairo', system-ui, Arial;
      direction:rtl;
      background: var(--bg);
      color:var(--text);
      background-attachment: fixed;
      animation: bgMove 30s infinite alternate ease-in-out;
    }
    @keyframes bgMove {
      0% {background-position: 0 0;}
      100% {background-position: 100% 100%;}
    }
    .container{max-width:980px;margin:20px auto;padding:16px}
    .card{
      background: var(--card);
      backdrop-filter: blur(12px);
      border-radius:20px;
      padding:20px;
      box-shadow: 0 0 30px rgba(255,110,199,0.2);
    }
    h1{
      margin:0 0 8px;
      font-size:22px;
      background: linear-gradient(90deg,var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-align:center;
    }
    p{text-align:center;margin-bottom:14px;color:var(--muted)}
    .chat{
      height:360px;overflow:auto;border-radius:12px;padding:12px;
      background: rgba(0,0,0,0.3);
      border:1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(6px);
      margin-top:12px;
    }
    .bubble{
      margin:6px 0;padding:10px 12px;border-radius:12px;max-width:75%;word-break:break-word;
      box-shadow: 0 0 10px rgba(255,255,255,0.05);
    }
    .me{
      background: linear-gradient(90deg,#ff6ec7,#ff9a9e);
      margin-left:auto;
    }
    .them{
      background: linear-gradient(90deg,#06b6d4,#4facfe);
      margin-right:auto;
    }
    .meta{font-size:12px;color:var(--muted);margin-bottom:4px}
    input,textarea,select,button{
      width:100%;box-sizing:border-box;background:rgba(255,255,255,0.05);
      border:1px solid rgba(255,255,255,0.1);
      padding:10px;border-radius:8px;color:var(--text);font-size:14px;
    }
    button{
      cursor:pointer;background:linear-gradient(90deg,var(--accent),var(--accent2));
      border:0;color:#fff;font-weight:600;
      box-shadow: 0 0 12px rgba(255,110,199,0.4);
    }
    .note{font-size:12px;color:var(--muted);margin-top:8px}
    footer{margin-top:14px;text-align:center;color:var(--muted);font-size:12px}
    @media(max-width:720px){
      .container{padding:10px}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Private Space ğŸ‘©â€â¤ï¸â€ğŸ‘¨</h1>
      <p>Ù…ÙƒØ§Ù†Ùƒ Ø§Ù„Ø¢Ù…Ù† Ù„Ù„Ø¨ÙˆØ­ ØªØ­Øª Ù†Ø¬ÙˆÙ… Ø§Ù„ÙØ¶Ø§Ø¡ ÙˆØ¥ÙŠÙ‚Ø§Ø¹Ø§Øª Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ ÙˆÙ†Ø¨Ø¶ Ø§Ù„Ø­Ø¨.</p>

      <div>
        <label>Ø§Ù„Ø§Ø³Ù… (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</label>
        <input id="nick" placeholder="Ø§Ø³Ù… Ù…Ø«Ù„: Ø²Ø§Ø¦Ø± Ø£Ùˆ Ø§ØªØ±ÙƒÙ‡ ÙØ§Ø±ØºÙ‹Ø§" />
      </div>
      <div style="margin-top:8px">
        <label>Ø§Ø¨Ù‚Ù Ù…ØªØ®ÙÙŠØ§Ù‹</label>
        <select id="anon">
          <option value="false">Ø¸Ø§Ù‡Ø±</option>
          <option value="true" selected>Ù…ØªØ®ÙÙ‘Ù</option>
        </select>
      </div>
      <div style="margin-top:8px">
        <label>Ø§Ù„Ø¹Ø¨Ø§Ø±Ø© Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© (Ù…ÙØªØ§Ø­ Ø§Ù„ØªØ´ÙÙŠØ±)</label>
        <input id="passphrase" placeholder="Ø¬Ù…Ù„Ø© Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø³Ø± Ù…Ø´ØªØ±ÙƒØ©" />
        <div class="note">ÙŠÙØ³ØªØ®Ø¯Ù… Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ÙØªØ§Ø­ AES Ø¹Ø¨Ø± PBKDF2. Ø´Ø§Ø±ÙƒÙ‡ Ø®Ø§Ø±Ø¬ Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆÙ‚Ø¹.</div>
      </div>

      <div style="margin-top:12px">
        <label>Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„</label>
        <input id="status" readonly value="ØºÙŠØ± Ù…ØªØµÙ„" />
      </div>
      <div style="margin-top:8px">
        <label>ØªØ´ÙÙŠØ±</label>
        <input id="encStatus" readonly value="ØºÙŠØ± Ù…Ù‡ÙŠØ£" />
      </div>

      <div class="chat" id="chat"></div>

      <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
        <input id="message" placeholder="Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„Ø©..." style="flex:1" />
        <button id="send">Ø¥Ø±Ø³Ø§Ù„</button>
        <button id="clear" class="muted-btn">Ù…Ø³Ø­</button>
      </div>

      <div class="note" style="margin-top:12px">
        Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¹Ù…Ù„:
        <ol style="margin:6px 0 0 18px;color:var(--muted)">
          <li>Ø§ÙØªØ­ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø¹Ù„Ù‰ Ø¬Ù‡Ø§Ø²ÙŠÙ† Ø£Ùˆ Ø´Ø§Ø±ÙƒÙ‡ Ø¹Ø¨Ø± GitHub Pages.</li>
          <li>Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØµÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¹Ø¨Ø± Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª.</li>
          <li>Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¹Ø¨Ø§Ø±Ø© Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ù†ÙØ³Ù‡Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø±ÙÙŠÙ† Ø«Ù… Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©.</li>
        </ol>
      </div>

      <footer>ØµÙÙ…Ù… Ù„Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙˆØ§Ù„Ø³Ù‡ÙˆÙ„Ø© Ø¹Ù„Ù‰ Ø´Ø§Ø´Ø§Øª Ø§Ù„Ù„Ù…Ø³ â€” ØªÙ…ÙƒÙŠÙ† WebRTC ÙˆClipboard Ù…Ø·Ù„ÙˆØ¨Ø§Ù†.</footer>
    </div>
  </div>

<script>
  let pc, dc;
  let aesKey = null;
  let ws;
  const serverUrl = "wss://signaling.simplewebrtc.com"; // Ø³ÙŠØ±ÙØ± Ø¥Ø´Ø§Ø±Ø§Øª Ø¹Ø§Ù… Ù…ÙØªÙˆØ­. ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ±Ù‡ Ù„Ø³ÙŠØ±ÙØ±Ùƒ Ø§Ù„Ø®Ø§Øµ.

  const nickInput = document.getElementById('nick');
  const anonSelect = document.getElementById('anon');
  const passphraseInput = document.getElementById('passphrase');
  const status = document.getElementById('status');
  const encStatus = document.getElementById('encStatus');
  const chat = document.getElementById('chat');
  const messageInput = document.getElementById('message');
  const sendBtn = document.getElementById('send');
  const clearBtn = document.getElementById('clear');

  // Ø¥Ø¶Ø§ÙØ© Ø±Ø³Ø§Ù„Ø© ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©
  function logBubble(text, who='them'){
    const b = document.createElement('div');
    b.className = 'bubble '+(who==='me'?'me':'them');
    const meta = document.createElement('div'); 
    meta.className='meta';
    meta.textContent = who==='me' ? (nickInput.value || 'Ù…ØªØ®ÙÙ') : 'Ø§Ù„Ø·Ø±Ù Ø§Ù„Ø¢Ø®Ø±';
    b.appendChild(meta);
    const t = document.createElement('div'); 
    t.textContent = text; 
    b.appendChild(t);
    chat.appendChild(b);
    chat.scrollTop = chat.scrollHeight;
  }

  // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„
  function setStatus(s){ status.value = s; }
  function setEnc(s){ encStatus.value = s; }

  // ØªÙˆÙ„ÙŠØ¯ Ù…ÙØªØ§Ø­ AES Ù…Ù† Ø§Ù„Ø¹Ø¨Ø§Ø±Ø© Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©
  async function deriveKey(pass){
    setEnc('Ù‚ÙŠØ¯ Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡...');
    const enc = new TextEncoder().encode(pass);
    const salt = new TextEncoder().encode('chat-salt-v1');
    const baseKey = await crypto.subtle.importKey('raw', enc, 'PBKDF2', false, ['deriveKey']);
    const key = await crypto.subtle.deriveKey(
      {name:'PBKDF2',salt:salt,iterations:100000,hash:'SHA-256'}, 
      baseKey, 
      {name:'AES-GCM',length:256}, 
      false, 
      ['encrypt','decrypt']
    );
    setEnc('Ù…ÙÙ‡ÙŠØ£');
    return key;
  }

  // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§ØªØµØ§Ù„ WebRTC
  function setupPeer(isOffer){
    pc = new RTCPeerConnection({iceServers:[{urls:['stun:stun.l.google.com:19302']}]});
    pc.oniceconnectionstatechange = ()=> setStatus(pc.iceConnectionState);
    pc.onicecandidate = e => {
      if(e.candidate) return;
      // Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ø¬Ù…Ø¹ ICE, Ø£Ø±Ø³Ù„ Ø§Ù„ÙˆØµÙ Ø§Ù„Ù…Ø­Ù„ÙŠ Ø¹Ø¨Ø± WS
      sendSignal({type: 'signal', data: pc.localDescription});
    };
    if(isOffer){
      dc = pc.createDataChannel('chat');
      initDC();
    }
    pc.ondatachannel = e=>{
      dc = e.channel;
      initDC();
    }
  }

  // Ø¥Ø¹Ø¯Ø§Ø¯ Ù‚Ù†Ø§Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  function initDC(){
    dc.onopen = ()=> setStatus('Ù‚Ù†Ø§Ø© Ù…ÙØªÙˆØ­Ø©');
    dc.onclose = ()=> setStatus('Ù…ØºÙ„Ù‚Ø©');
    dc.onmessage = async (e)=>{
      try{
        const obj = JSON.parse(e.data);
        if(obj.type==='msg'){
          const plaintext = await decryptMessage(obj.payload);
          logBubble(plaintext,'them');
        }
      }catch(err){console.error(err)}
    }
  }

  // ØªØ´ÙÙŠØ± Ø±Ø³Ø§Ù„Ø©
  async function encryptMessage(text){ 
    if(!aesKey) throw new Error('Ù…ÙØªØ§Ø­ Ø§Ù„ØªØ´ÙÙŠØ± ØºÙŠØ± Ù…ÙÙ‡ÙŠØ£');
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const enc = new TextEncoder().encode(text);
    const ct = await crypto.subtle.encrypt({name:'AES-GCM',iv}, aesKey, enc);
    return JSON.stringify({iv:Array.from(iv),ct:Array.from(new Uint8Array(ct))});
  }

  // ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±
  async function decryptMessage(payload){ 
    if(!aesKey) throw new Error('Ù…ÙØªØ§Ø­ Ø§Ù„ØªØ´ÙÙŠØ± ØºÙŠØ± Ù…ÙÙ‡ÙŠØ£');
    const obj = payload;
    const iv = new Uint8Array(obj.iv);
    const ct = new Uint8Array(obj.ct);
    const plain = await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct);
    return new TextDecoder().decode(plain);
  }

  // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¹Ø¨Ø± WebSocket Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª
  function sendSignal(message){
    if(ws && ws.readyState === WebSocket.OPEN){
      ws.send(JSON.stringify(message));
    }
  }

  // Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ WebSocket
  function handleSignal(data){
    if(data.type === 'signal'){
      const desc = data.data;
      if(desc.type === 'offer'){
        setupPeer(false);
        pc.setRemoteDescription(desc).then(()=>{
          return pc.createAnswer();
        }).then(answer=>{
          return pc.setLocalDescription(answer);
        }).then(()=>{
          sendSignal({type:'signal', data: pc.localDescription});
          setStatus('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Answer');
        }).catch(console.error);
      } else if(desc.type === 'answer'){
        pc.setRemoteDescription(desc).catch(console.error);
        setStatus('ØªÙ… Ù‚Ø¨ÙˆÙ„ Answer');
      }
    } else if(data.type === 'ice-candidate'){
      if(pc){
        pc.addIceCandidate(data.candidate).catch(console.error);
      }
    }
  }

  // Ø¨Ø¯Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª
  function startWebSocket(){
    ws = new WebSocket(serverUrl);

    ws.onopen = () => {
      setStatus('Ù…ØªØµÙ„ Ø¨Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª');
      // Ø§Ù„Ø·Ø±Ù Ø§Ù„Ø£ÙˆÙ„ ÙŠØ¨Ø¯Ø£ Ø¨Ø¥Ù†Ø´Ø§Ø¡ offer
      setupPeer(true);
      pc.createOffer().then(offer=>{
        return pc.setLocalDescription(offer);
      }).catch(console.error);
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        handleSignal(data);
      } catch (e) {
        console.error('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø´Ø§Ø±Ø©:', e);
      }
    };

    ws.onerror = (e) => {
      setStatus('Ø®Ø·Ø£ ÙÙŠ Ø§ØªØµØ§Ù„ Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª');
      console.error('WebSocket error:', e);
    };

    ws.onclose = () => {
      setStatus('Ø§Ù†Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„ Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª');
    };
  }

  // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù…Ø´ÙØ±Ø© Ø¹Ø¨Ø± Ù‚Ù†Ø§Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  sendBtn.onclick = async () => {
    const txt = messageInput.value.trim();
    if(!txt) return;
    if(!dc || dc.readyState !== 'open') return alert('Ø§Ù„Ù‚Ù†Ø§Ø© ØºÙŠØ± Ù…ÙØªÙˆØ­Ø©');
    try {
      if(!aesKey){ 
        const pass = passphraseInput.value; 
        if(!pass) return alert('Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¹Ø¨Ø§Ø±Ø© Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©'); 
        aesKey = await deriveKey(pass); 
      }
      const encrypted = await encryptMessage(txt);
      dc.send(JSON.stringify({type:'msg',payload:JSON.parse(encrypted)}));
      logBubble(txt,'me');
      messageInput.value = '';
    } catch(err) {
      alert('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: '+err.message);
      console.error(err);
    }
  };

  clearBtn.onclick = () => { chat.innerHTML = ''; };

  messageInput.addEventListener('keydown', e => { if(e.key === 'Enter'){ e.preventDefault(); sendBtn.click(); } });

  window.addEventListener('load', () => {
    if(!window.RTCPeerConnection){ setStatus('WebRTC ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…ØªØµÙØ­'); }
    if(!navigator.clipboard){ console.warn('Clipboard API ØºÙŠØ± Ù…ØªØ§Ø­'); }
    startWebSocket();
  });
</script>

</body>
</html>
